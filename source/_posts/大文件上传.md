---
title: 大文件上传
date: 2024-12-04 17:55:19
tags:
  - Promise
  - TypeScript
---
### 1. `sliceFile` 函数（切片文件）

将大文件切割成多个小切片。每个切片的大小可以由 `chunkSize` 控制。

```typescript
function sliceFile(file: File, chunkSize: number): Blob[] {
  const chunks: Blob[] = [];
  let start = 0;
  let end = chunkSize;

  while (start < file.size) {
    chunks.push(file.slice(start, end));
    start = end;
    end = Math.min(start + chunkSize, file.size);
  }

  return chunks;
}
```

### 2. `uploadChunkWithRetry` 函数（上传单个切片）

上传单个切片，计算上传进度，并处理错误重试机制。

```typescript
import axios, { AxiosRequestConfig, AxiosProgressEvent } from 'axios';

interface ProgressCallback {
  (totalProgress: number, chunkIndex: number): void;
}

async function uploadChunkWithRetry(
  file: File,
  chunk: Blob,
  chunkIndex: number,
  totalChunks: number,
  chunkSize: number,
  totalFileSize: number,
  maxRetries: number = 3,
  onProgress: ProgressCallback
): Promise<void> {
  let retries = 0;
  
  while (retries < maxRetries) {
    try {
      const formData = new FormData();
      formData.append('file', chunk);  // 添加文件切片
      formData.append('fileName', file.name);
      formData.append('chunkIndex', chunkIndex.toString());
      formData.append('totalChunks', totalChunks.toString());

      const config: AxiosRequestConfig = {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
        onUploadProgress: (progressEvent: AxiosProgressEvent) => {
          if (progressEvent.total) {
            const chunkProgress = (progressEvent.loaded / progressEvent.total);
            const totalProgress = (chunkProgress * chunkSize) / totalFileSize;
            onProgress(totalProgress, chunkIndex);  // 计算并回调进度
          }
        },
      };

      await axios.post('/upload', formData, config);  // 上传切片

      console.log(`Chunk ${chunkIndex} uploaded successfully.`);
      return;  // 上传成功
    } catch (error) {
      retries++;
      console.error(`Error uploading chunk ${chunkIndex}. Retry ${retries}/${maxRetries}.`, error);
      if (retries >= maxRetries) {
        throw new Error(`Chunk ${chunkIndex} failed after ${maxRetries} attempts.`);
      }
    }
  }
}
```

### 3. `uploadFileWithLimit` 函数（控制并发上传并计算总进度）

控制最大并发数并计算整个文件的上传进度。

```typescript
// 模拟获取已上传切片索引（可以通过后端API来获取）
async function getUploadedChunks(fileName: string): Promise<number[]> {
  return [0, 1];  // 假设切片 0 和 1 已上传
}

// 控制并发上传并计算总进度
async function uploadFileWithLimit(
  file: File,
  maxConcurrency: number = 3,
  maxRetries: number = 3,
  onProgress: (progress: number) => void
): Promise<void> {
  const chunks = sliceFile(file, 2 * 1024 * 1024);  // 切片文件，每个切片 2MB
  const uploadedChunks = await getUploadedChunks(file.name);  // 获取已上传的切片

  let index = 0;
  const uploadQueue: Promise<void>[] = [];
  let totalFileSize = file.size;  // 文件总大小
  let totalProgress = 0;  // 累加的进度
  let totalProgressPercentage = 0;  // 总进度百分比

  // 持续上传直到所有切片上传完成
  while (index < chunks.length) {
    if (!uploadedChunks.includes(index)) {
      const chunk = chunks[index];
      const chunkSize = chunk.size;  // 当前切片的大小

      const uploadPromise = uploadChunkWithRetry(
        file,
        chunk,
        index,
        chunks.length,
        chunkSize,
        totalFileSize,
        maxRetries,
        (progress: number, chunkIndex: number) => {
          totalProgress += progress;
          totalProgressPercentage = (totalProgress / chunks.length) * 100;
          onProgress(totalProgressPercentage);  // 更新进度
        }
      );

      uploadQueue.push(uploadPromise);

      // 控制并发数
      if (uploadQueue.length >= maxConcurrency) {
        try {
          await Promise.race(uploadQueue);  // 等待最先完成的任务
        } catch (error) {
          console.error(`Error in uploading chunk ${index}.`, error);
        }
      }
    }

    index++;
  }

  // 等待所有上传任务完成（无论是否有错误）
  try {
    await Promise.all(uploadQueue);
  } catch (error) {
    console.error('Error in uploading some chunks.', error);
  }
}
```

### 4. 进度回调和进度条更新函数

创建进度回调函数并更新进度条。

```typescript
// 进度回调函数，显示上传总进度
function handleProgress(totalProgressPercentage: number): void {
  console.log(`Total upload progress: ${totalProgressPercentage.toFixed(2)}%`);
  updateProgressBar(totalProgressPercentage);
}

// 更新进度条
function updateProgressBar(progress: number): void {
  const progressBar = document.getElementById('progressBar') as HTMLElement;
  progressBar.style.width = `${progress}%`;
  document.getElementById('progressText')!.innerText = `${progress.toFixed(2)}% Uploaded`;
}
```

### 5. HTML 页面（用于显示进度条）

在 HTML 页面中，创建一个简单的进度条来显示上传进度。

```html
<div id="uploadContainer">
  <div id="progressWrapper" style="width: 100%; background: #eee;">
    <div id="progressBar" style="width: 0%; height: 30px; background-color: #4caf50;"></div>
  </div>
  <p id="progressText">0% Uploaded</p>
</div>

<input type="file" id="fileInput" />
```

### 6. 触发上传

监听文件输入事件，并启动上传过程。

```typescript
const fileInput = document.getElementById('fileInput') as HTMLInputElement;

fileInput.addEventListener('change', (event) => {
  const file = (event.target as HTMLInputElement).files?.[0];
  if (file) {
    uploadFileWithLimit(file, 3, 3, handleProgress);  // 3 是最大并发数，3 是最大重试次数
  }
});
```

### 7. 完整实现总结

* **文件切片**：大文件被切分为多个小切片。
* **上传每个切片**：通过 `axios` 实现每个切片的上传，使用 `onUploadProgress` 事件来计算进度。
* **并发控制**：使用 `Promise.race` 控制并发上传的切片数量，确保不会同时上传过多切片。
* **错误重试机制**：如果上传失败，最多重试 `maxRetries` 次。
* **总进度计算**：根据每个切片的大小，计算整个文件的上传进度，并通过回调函数实时更新进度条。
* **UI 更新**：进度条在上传过程中动态更新，显示上传的百分比。
