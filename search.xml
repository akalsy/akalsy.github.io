<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React中diff算法原理与实现</title>
    <url>/2024/11/18/React%E4%B8%ADdiff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>React 中的 <strong>Diff 算法</strong> 是其虚拟 DOM 的核心，用于高效地比较新旧虚拟 DOM 树，并生成最小的更新操作集合以更新实际 DOM。由于 DOM 操作通常是性能瓶颈，React 的 Diff 算法基于一系列假设和优化策略，实现了近似的最优性能。</p>
<hr>
<h2 id="1-Diff-算法的基本原则"><a href="#1-Diff-算法的基本原则" class="headerlink" title="1. Diff 算法的基本原则"></a><strong>1. Diff 算法的基本原则</strong></h2><p>React 的 Diff 算法并非传统意义上的 O(n³) 完全对比，而是基于以下三条核心策略进行了优化：</p>
<ol>
<li><p><strong>树的分层比较</strong></p>
<ul>
<li>React 假设两个组件的层级结构相同，子节点的比较只会在同一层进行，不会跨层级比较。</li>
<li>如果某一层的根节点类型不同，直接删除旧节点并创建新节点，忽略其子树。</li>
</ul>
</li>
<li><p><strong>同级节点的 key 优化</strong></p>
<ul>
<li>React 使用 <code>key</code> 来识别同级的子节点是否为相同元素。</li>
<li>若 key 不同，React 会认为它们是不同的节点，并重新创建。</li>
</ul>
</li>
<li><p><strong>组件的类型优先级</strong></p>
<ul>
<li>对于类组件或函数组件，如果类型相同，则复用组件实例并更新其 props。</li>
<li>如果类型不同，直接卸载旧组件并重新创建新组件。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-Diff-算法的三大过程"><a href="#2-Diff-算法的三大过程" class="headerlink" title="2. Diff 算法的三大过程"></a><strong>2. Diff 算法的三大过程</strong></h2><p>React 的 Diff 算法主要分为以下三个过程：</p>
<h3 id="2-1-节点树的比较"><a href="#2-1-节点树的比较" class="headerlink" title="2.1 节点树的比较"></a><strong>2.1 节点树的比较</strong></h3><ul>
<li><p><strong>相同类型节点</strong>：更新属性。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;old&quot;</span> /&gt; =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;new&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>React 比较 <code>div</code> 的类型相同，只更新属性 <code>id</code>。</li>
</ul>
</li>
<li><p><strong>不同类型节点</strong>：直接替换整个节点。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div /&gt; =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>React 会移除旧的 <code>div</code> 节点，并新建 <code>span</code> 节点。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-2-子节点的比较"><a href="#2-2-子节点的比较" class="headerlink" title="2.2 子节点的比较"></a><strong>2.2 子节点的比较</strong></h3><p>子节点的比较是 React Diff 算法的重点，具体策略如下：</p>
<h4 id="2-2-1-简单情况"><a href="#2-2-1-简单情况" class="headerlink" title="2.2.1 简单情况"></a><strong>2.2.1 简单情况</strong></h4><p>如果子节点是一个列表且没有 <code>key</code>，React 会按照索引逐个比较。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>当更新为：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>React 会直接复用第一个 <code>li</code>，并更新第二个 <code>li</code>。</p>
<h4 id="2-2-2-使用-key-优化比较"><a href="#2-2-2-使用-key-优化比较" class="headerlink" title="2.2.2 使用 key 优化比较"></a><strong>2.2.2 使用 <code>key</code> 优化比较</strong></h4><p>如果子节点带有 <code>key</code> 属性，React 会根据 <code>key</code> 进行匹配，而不是简单地按顺序比较。</p>
<p>示例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>更新为：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;b&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;a&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>React 会通过 <code>key</code> 发现节点位置交换。</li>
<li>而不是删除和重新创建这两个节点。</li>
</ul>
<p>这种 <code>key</code> 优化可以显著提高列表动态更新时的性能。</p>
<hr>
<h3 id="2-3-组件的比较"><a href="#2-3-组件的比较" class="headerlink" title="2.3 组件的比较"></a><strong>2.3 组件的比较</strong></h3><ul>
<li><p><strong>相同类型的组件</strong>：保留组件实例，更新 <code>props</code>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">ComponentA</span> prop=<span class="string">&quot;old&quot;</span> /&gt; =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">ComponentA</span> <span class="attr">prop</span>=<span class="string">&quot;new&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>React 会调用 <code>ComponentA</code> 的生命周期方法（如 <code>shouldComponentUpdate</code> 或 <code>useEffect</code>），只更新其属性。</p>
</li>
<li><p><strong>不同类型的组件</strong>：卸载旧组件，创建新组件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">ComponentA</span> /&gt; =&gt; <span class="language-xml"><span class="tag">&lt;<span class="name">ComponentB</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>React 会销毁 <code>ComponentA</code> 的实例，并重新渲染 <code>ComponentB</code>。</p>
</li>
</ul>
<hr>
<h2 id="3-Diff-算法的实现细节"><a href="#3-Diff-算法的实现细节" class="headerlink" title="3. Diff 算法的实现细节"></a><strong>3. Diff 算法的实现细节</strong></h2><h3 id="3-1-整体流程"><a href="#3-1-整体流程" class="headerlink" title="3.1 整体流程"></a><strong>3.1 整体流程</strong></h3><p>React 的虚拟 DOM 树由 Fiber 数据结构表示，Diff 过程基于 Fiber 节点进行递归：</p>
<ol>
<li><strong>比较节点类型</strong>：<ul>
<li>类型相同：更新属性。</li>
<li>类型不同：替换整个节点。</li>
</ul>
</li>
<li><strong>比较子节点</strong>：<ul>
<li>通过 <code>key</code> 确定是否需要移动或复用节点。</li>
<li>遍历列表的新增、删除或更新操作。</li>
</ul>
</li>
<li><strong>生成更新队列</strong>：<ul>
<li>记录需要执行的操作，最终批量更新真实 DOM。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-2-key-的作用"><a href="#3-2-key-的作用" class="headerlink" title="3.2 key 的作用"></a><strong>3.2 <code>key</code> 的作用</strong></h3><p>React 通过 <code>key</code> 来跟踪子节点的身份，解决以下问题：</p>
<ul>
<li>当节点顺序发生变化时，避免不必要的移除和重新创建。</li>
<li>提高列表渲染的性能。</li>
</ul>
<p><strong>无 <code>key</code> 的情况</strong>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>变更为：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>React 会重新创建所有节点。</p>
<p><strong>有 <code>key</code> 的情况</strong>：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>变更为：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>One<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>React 会通过 <code>key</code> 检测顺序变化，只更新位置。</p>
<hr>
<h2 id="4-Diff-算法的复杂度"><a href="#4-Diff-算法的复杂度" class="headerlink" title="4. Diff 算法的复杂度"></a><strong>4. Diff 算法的复杂度</strong></h2><p>React 的 Diff 算法通过以下方式优化复杂度：</p>
<ul>
<li><strong>树分层比较</strong>：将复杂度从 O(n³) 降低到 O(n)。</li>
<li><strong><code>key</code> 优化</strong>：减少列表中的重新渲染。</li>
</ul>
<p>具体复杂度分析：</p>
<ul>
<li><strong>节点类型比较</strong>：O(1)。</li>
<li><strong>属性比较</strong>：O(n)，其中 n 是属性数量。</li>
<li><strong>子节点比较</strong>：<ul>
<li>无 <code>key</code> 时：O(n)。</li>
<li>有 <code>key</code> 时：O(n) + O(m)，其中 m 是 <code>key</code> 查找的哈希表操作复杂度。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-Diff-的限制与优化建议"><a href="#5-Diff-的限制与优化建议" class="headerlink" title="5. Diff 的限制与优化建议"></a><strong>5. Diff 的限制与优化建议</strong></h2><h3 id="5-1-限制"><a href="#5-1-限制" class="headerlink" title="5.1 限制"></a><strong>5.1 限制</strong></h3><ul>
<li><strong>跨层级移动</strong>：React 不会优化跨层级的节点移动，因为假设节点层级不会变化。</li>
<li>**缺乏唯一 <code>key</code>**：若没有提供稳定的 <code>key</code>，性能可能下降，甚至导致渲染错误。</li>
</ul>
<h3 id="5-2-优化建议"><a href="#5-2-优化建议" class="headerlink" title="5.2 优化建议"></a><strong>5.2 优化建议</strong></h3><ol>
<li>**使用稳定的 <code>key</code>**：<ul>
<li>避免使用索引作为 <code>key</code>。</li>
<li>提供唯一标识，如数据库的 <code>id</code>。</li>
</ul>
</li>
<li><strong>减少 DOM 层级的无关变化</strong>：<ul>
<li>避免频繁改变节点的层级结构。</li>
</ul>
</li>
<li><strong>分离独立部分</strong>：<ul>
<li>将不相关的 UI 拆分成独立组件，减少 Diff 范围。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>React 的 Diff 算法基于简化规则和分层比较策略，实现了高效的虚拟 DOM 更新。通过使用 <code>key</code> 优化列表比较和组件类型判断，React 能够在绝大多数场景中保持出色的性能。但在特定场景下，开发者仍需通过优化 <code>key</code> 和组件设计来提高性能。</p>
]]></content>
      <tags>
        <tag>React</tag>
        <tag>Diff</tag>
      </tags>
  </entry>
  <entry>
    <title>大文件上传</title>
    <url>/2024/12/04/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h3 id="1-sliceFile-函数（切片文件）"><a href="#1-sliceFile-函数（切片文件）" class="headerlink" title="1. sliceFile 函数（切片文件）"></a>1. <code>sliceFile</code> 函数（切片文件）</h3><p>将大文件切割成多个小切片。每个切片的大小可以由 <code>chunkSize</code> 控制。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sliceFile</span>(<span class="params">file: File, chunkSize: <span class="built_in">number</span></span>): <span class="title class_">Blob</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">chunks</span>: <span class="title class_">Blob</span>[] = [];</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> end = chunkSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; file.<span class="property">size</span>) &#123;</span><br><span class="line">    chunks.<span class="title function_">push</span>(file.<span class="title function_">slice</span>(start, end));</span><br><span class="line">    start = end;</span><br><span class="line">    end = <span class="title class_">Math</span>.<span class="title function_">min</span>(start + chunkSize, file.<span class="property">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> chunks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-uploadChunkWithRetry-函数（上传单个切片）"><a href="#2-uploadChunkWithRetry-函数（上传单个切片）" class="headerlink" title="2. uploadChunkWithRetry 函数（上传单个切片）"></a>2. <code>uploadChunkWithRetry</code> 函数（上传单个切片）</h3><p>上传单个切片，计算上传进度，并处理错误重试机制。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; <span class="title class_">AxiosRequestConfig</span>, <span class="title class_">AxiosProgressEvent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProgressCallback</span> &#123;</span><br><span class="line">  (<span class="attr">totalProgress</span>: <span class="built_in">number</span>, <span class="attr">chunkIndex</span>: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">uploadChunkWithRetry</span>(<span class="params"></span></span><br><span class="line"><span class="params">  file: File,</span></span><br><span class="line"><span class="params">  chunk: Blob,</span></span><br><span class="line"><span class="params">  chunkIndex: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  totalChunks: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  chunkSize: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  totalFileSize: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  maxRetries: <span class="built_in">number</span> = <span class="number">3</span>,</span></span><br><span class="line"><span class="params">  onProgress: ProgressCallback</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> retries = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (retries &lt; maxRetries) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, chunk);  <span class="comment">// 添加文件切片</span></span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&#x27;fileName&#x27;</span>, file.<span class="property">name</span>);</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&#x27;chunkIndex&#x27;</span>, chunkIndex.<span class="title function_">toString</span>());</span><br><span class="line">      formData.<span class="title function_">append</span>(<span class="string">&#x27;totalChunks&#x27;</span>, totalChunks.<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="attr">config</span>: <span class="title class_">AxiosRequestConfig</span> = &#123;</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onUploadProgress</span>: <span class="function">(<span class="params">progressEvent: AxiosProgressEvent</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (progressEvent.<span class="property">total</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> chunkProgress = (progressEvent.<span class="property">loaded</span> / progressEvent.<span class="property">total</span>);</span><br><span class="line">            <span class="keyword">const</span> totalProgress = (chunkProgress * chunkSize) / totalFileSize;</span><br><span class="line">            <span class="title function_">onProgress</span>(totalProgress, chunkIndex);  <span class="comment">// 计算并回调进度</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;/upload&#x27;</span>, formData, config);  <span class="comment">// 上传切片</span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Chunk <span class="subst">$&#123;chunkIndex&#125;</span> uploaded successfully.`</span>);</span><br><span class="line">      <span class="keyword">return</span>;  <span class="comment">// 上传成功</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      retries++;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Error uploading chunk <span class="subst">$&#123;chunkIndex&#125;</span>. Retry <span class="subst">$&#123;retries&#125;</span>/<span class="subst">$&#123;maxRetries&#125;</span>.`</span>, error);</span><br><span class="line">      <span class="keyword">if</span> (retries &gt;= maxRetries) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Chunk <span class="subst">$&#123;chunkIndex&#125;</span> failed after <span class="subst">$&#123;maxRetries&#125;</span> attempts.`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-uploadFileWithLimit-函数（控制并发上传并计算总进度）"><a href="#3-uploadFileWithLimit-函数（控制并发上传并计算总进度）" class="headerlink" title="3. uploadFileWithLimit 函数（控制并发上传并计算总进度）"></a>3. <code>uploadFileWithLimit</code> 函数（控制并发上传并计算总进度）</h3><p>控制最大并发数并计算整个文件的上传进度。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟获取已上传切片索引（可以通过后端API来获取）</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUploadedChunks</span>(<span class="params">fileName: <span class="built_in">string</span></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">number</span>[]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">1</span>];  <span class="comment">// 假设切片 0 和 1 已上传</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制并发上传并计算总进度</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">uploadFileWithLimit</span>(<span class="params"></span></span><br><span class="line"><span class="params">  file: File,</span></span><br><span class="line"><span class="params">  maxConcurrency: <span class="built_in">number</span> = <span class="number">3</span>,</span></span><br><span class="line"><span class="params">  maxRetries: <span class="built_in">number</span> = <span class="number">3</span>,</span></span><br><span class="line"><span class="params">  onProgress: (progress: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> chunks = <span class="title function_">sliceFile</span>(file, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);  <span class="comment">// 切片文件，每个切片 2MB</span></span><br><span class="line">  <span class="keyword">const</span> uploadedChunks = <span class="keyword">await</span> <span class="title function_">getUploadedChunks</span>(file.<span class="property">name</span>);  <span class="comment">// 获取已上传的切片</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">uploadQueue</span>: <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;[] = [];</span><br><span class="line">  <span class="keyword">let</span> totalFileSize = file.<span class="property">size</span>;  <span class="comment">// 文件总大小</span></span><br><span class="line">  <span class="keyword">let</span> totalProgress = <span class="number">0</span>;  <span class="comment">// 累加的进度</span></span><br><span class="line">  <span class="keyword">let</span> totalProgressPercentage = <span class="number">0</span>;  <span class="comment">// 总进度百分比</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 持续上传直到所有切片上传完成</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; chunks.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!uploadedChunks.<span class="title function_">includes</span>(index)) &#123;</span><br><span class="line">      <span class="keyword">const</span> chunk = chunks[index];</span><br><span class="line">      <span class="keyword">const</span> chunkSize = chunk.<span class="property">size</span>;  <span class="comment">// 当前切片的大小</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> uploadPromise = <span class="title function_">uploadChunkWithRetry</span>(</span><br><span class="line">        file,</span><br><span class="line">        chunk,</span><br><span class="line">        index,</span><br><span class="line">        chunks.<span class="property">length</span>,</span><br><span class="line">        chunkSize,</span><br><span class="line">        totalFileSize,</span><br><span class="line">        maxRetries,</span><br><span class="line">        <span class="function">(<span class="params">progress: <span class="built_in">number</span>, chunkIndex: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">          totalProgress += progress;</span><br><span class="line">          totalProgressPercentage = (totalProgress / chunks.<span class="property">length</span>) * <span class="number">100</span>;</span><br><span class="line">          <span class="title function_">onProgress</span>(totalProgressPercentage);  <span class="comment">// 更新进度</span></span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      uploadQueue.<span class="title function_">push</span>(uploadPromise);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 控制并发数</span></span><br><span class="line">      <span class="keyword">if</span> (uploadQueue.<span class="property">length</span> &gt;= maxConcurrency) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>(uploadQueue);  <span class="comment">// 等待最先完成的任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Error in uploading chunk <span class="subst">$&#123;index&#125;</span>.`</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待所有上传任务完成（无论是否有错误）</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(uploadQueue);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error in uploading some chunks.&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-进度回调和进度条更新函数"><a href="#4-进度回调和进度条更新函数" class="headerlink" title="4. 进度回调和进度条更新函数"></a>4. 进度回调和进度条更新函数</h3><p>创建进度回调函数并更新进度条。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进度回调函数，显示上传总进度</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleProgress</span>(<span class="params">totalProgressPercentage: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Total upload progress: <span class="subst">$&#123;totalProgressPercentage.toFixed(<span class="number">2</span>)&#125;</span>%`</span>);</span><br><span class="line">  <span class="title function_">updateProgressBar</span>(totalProgressPercentage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新进度条</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgressBar</span>(<span class="params">progress: <span class="built_in">number</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> progressBar = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progressBar&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span>;</span><br><span class="line">  progressBar.<span class="property">style</span>.<span class="property">width</span> = <span class="string">`<span class="subst">$&#123;progress&#125;</span>%`</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;progressText&#x27;</span>)!.<span class="property">innerText</span> = <span class="string">`<span class="subst">$&#123;progress.toFixed(<span class="number">2</span>)&#125;</span>% Uploaded`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-HTML-页面（用于显示进度条）"><a href="#5-HTML-页面（用于显示进度条）" class="headerlink" title="5. HTML 页面（用于显示进度条）"></a>5. HTML 页面（用于显示进度条）</h3><p>在 HTML 页面中，创建一个简单的进度条来显示上传进度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;uploadContainer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progressWrapper&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; background: #eee;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progressBar&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 0%; height: 30px; background-color: #4caf50;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;progressText&quot;</span>&gt;</span>0% Uploaded<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-触发上传"><a href="#6-触发上传" class="headerlink" title="6. 触发上传"></a>6. 触发上传</h3><p>监听文件输入事件，并启动上传过程。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fileInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>;</span><br><span class="line"></span><br><span class="line">fileInput.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> file = (event.<span class="property">target</span> <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>).<span class="property">files</span>?.[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    <span class="title function_">uploadFileWithLimit</span>(file, <span class="number">3</span>, <span class="number">3</span>, handleProgress);  <span class="comment">// 3 是最大并发数，3 是最大重试次数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="7-完整实现总结"><a href="#7-完整实现总结" class="headerlink" title="7. 完整实现总结"></a>7. 完整实现总结</h3><ul>
<li><strong>文件切片</strong>：大文件被切分为多个小切片。</li>
<li><strong>上传每个切片</strong>：通过 <code>axios</code> 实现每个切片的上传，使用 <code>onUploadProgress</code> 事件来计算进度。</li>
<li><strong>并发控制</strong>：使用 <code>Promise.race</code> 控制并发上传的切片数量，确保不会同时上传过多切片。</li>
<li><strong>错误重试机制</strong>：如果上传失败，最多重试 <code>maxRetries</code> 次。</li>
<li><strong>总进度计算</strong>：根据每个切片的大小，计算整个文件的上传进度，并通过回调函数实时更新进度条。</li>
<li><strong>UI 更新</strong>：进度条在上传过程中动态更新，显示上传的百分比。</li>
</ul>
]]></content>
      <tags>
        <tag>Promise</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 泛型</title>
    <url>/2024/11/23/TypeScript-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>在 TypeScript 中，<strong>泛型</strong>（Generics）是一种强大的工具，用于定义能够处理多种类型的函数、类和接口，而不失去类型安全性。它允许我们编写可复用的代码，避免类型重复，并且提高了代码的灵活性和可维护性。</p>
<p>泛型的核心思想是<strong>抽象类型</strong>，使得我们可以在编写代码时指定一个<strong>类型占位符</strong>，在使用时再指定具体的类型。</p>
<h3 id="1-基础概念：泛型的作用"><a href="#1-基础概念：泛型的作用" class="headerlink" title="1. 基础概念：泛型的作用"></a>1. <strong>基础概念：泛型的作用</strong></h3><p>通过泛型，我们可以在定义函数、类或接口时，让它们适应多种数据类型，而不需要在每次使用时都重复写出类型。</p>
<p>例如，我们希望定义一个能够处理不同类型的函数，而不管数据类型是 <code>number</code>、<code>string</code> 还是其他类型，使用泛型可以让这个函数更具通用性。</p>
<h4 id="1-1-泛型函数"><a href="#1-1-泛型函数" class="headerlink" title="1.1 泛型函数"></a>1.1 泛型函数</h4><p>我们首先来看一个普通的函数，它的类型已经固定了：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="title function_">identity</span>(<span class="number">5</span>);  <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="title function_">identity</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// Error: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>上面的函数只能接受 <code>number</code> 类型的值，并且返回 <code>number</code> 类型。这个函数无法用于处理其他类型的数据，若要复用此函数，我们需要为不同的类型编写多个版本，代码冗长且不易维护。</p>
<p>通过使用泛型，可以实现类型的灵活性：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">value</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="title function_">identity</span>(<span class="number">5</span>);       <span class="comment">// 合法，类型推导为 number</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="title function_">identity</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 合法，类型推导为 string</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T</code> 是一个泛型参数，它代表了一个占位符，表示函数可以接受和返回任意类型。你可以在函数调用时自动推导出类型，也可以显式指定类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = identity&lt;<span class="built_in">number</span>&gt;(<span class="number">5</span>); <span class="comment">// 显式指定 T 为 number</span></span><br><span class="line"><span class="keyword">let</span> str = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 显式指定 T 为 string</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-泛型类型约束"><a href="#1-2-泛型类型约束" class="headerlink" title="1.2 泛型类型约束"></a>1.2 泛型类型约束</h4><p>有时，你可能希望限制泛型类型的范围，比如要求泛型参数必须是某个特定类型的子类型。在这种情况下，可以使用 <strong>类型约束</strong> 来约束泛型类型。</p>
<p>例如，假设我们希望传入的 <code>value</code> 必须是 <code>length</code> 属性存在的对象（如 <code>string</code> 或 <code>array</code>），我们可以这样做：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> logLength&lt;T <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">value</span>: T): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">logLength</span>(<span class="string">&quot;Hello&quot;</span>));    <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">logLength</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));  <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">logLength</span>(<span class="number">5</span>));          <span class="comment">// Error: Argument of type &#x27;5&#x27; is not assignable to parameter of type &#x27;&#123; length: number; &#125;&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>T extends &#123; length: number &#125;</code> 表示泛型 <code>T</code> 必须是一个拥有 <code>length</code> 属性的类型，<code>string</code>、<code>array</code> 等类型符合这一约束，但 <code>number</code> 类型不符合。</p>
<hr>
<h3 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="2. 泛型接口"></a>2. <strong>泛型接口</strong></h3><p>除了泛型函数外，TypeScript 还允许我们在接口中使用泛型来描述类型。</p>
<h4 id="2-1-泛型接口的基本用法"><a href="#2-1-泛型接口的基本用法" class="headerlink" title="2.1 泛型接口的基本用法"></a>2.1 泛型接口的基本用法</h4><p>例如，我们可以定义一个泛型接口，它指定了一个方法，该方法的返回类型和输入类型都是泛型类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdentityFn</span>&lt;T&gt; &#123;</span><br><span class="line">  (<span class="attr">value</span>: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">identity</span>: <span class="title class_">IdentityFn</span>&lt;<span class="built_in">number</span>&gt; = <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">identity</span>(<span class="number">5</span>));  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>IdentityFn</code> 接口定义了一个泛型函数类型，它接受一个 <code>T</code> 类型的参数并返回 <code>T</code> 类型的值。我们为 <code>IdentityFn</code> 接口指定了具体类型 <code>number</code>。</p>
<h4 id="2-2-泛型接口的约束"><a href="#2-2-泛型接口的约束" class="headerlink" title="2.2 泛型接口的约束"></a>2.2 泛型接口的约束</h4><p>你还可以为泛型接口指定约束。比如，假设我们希望泛型参数 <code>T</code> 必须是一个对象类型，且该对象必须有一个 <code>name</code> 属性，我们可以这样定义：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">personInfo</span>: <span class="title class_">Info</span>&lt;<span class="title class_">Person</span>&gt; = &#123; <span class="attr">value</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Info</code> 接口的泛型参数 <code>T</code> 必须是 <code>Person</code> 类型的子类型，因此 <code>personInfo</code> 必须包含一个 <code>name</code> 和 <code>age</code> 属性。</p>
<hr>
<h3 id="3-泛型类"><a href="#3-泛型类" class="headerlink" title="3. 泛型类"></a>3. <strong>泛型类</strong></h3><p>类也可以使用泛型。泛型类的作用和泛型函数类似，可以使类能够处理多种类型。</p>
<h4 id="3-1-泛型类的基本用法"><a href="#3-1-泛型类的基本用法" class="headerlink" title="3.1 泛型类的基本用法"></a>3.1 泛型类的基本用法</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">value</span>: T;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getValue</span>(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberBox = <span class="keyword">new</span> <span class="title class_">Box</span>(<span class="number">123</span>);    <span class="comment">// 泛型 T 被推导为 number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numberBox.<span class="title function_">getValue</span>()); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 泛型 T 被推导为 string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringBox.<span class="title function_">getValue</span>());  <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Box</code> 是一个泛型类，它可以包装任何类型的值。通过 <code>T</code>，我们可以在实例化时指定类型。</p>
<h4 id="3-2-泛型类的构造函数"><a href="#3-2-泛型类的构造函数" class="headerlink" title="3.2 泛型类的构造函数"></a>3.2 泛型类的构造函数</h4><p>泛型类也可以有带泛型参数的构造函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, U&gt; &#123;</span><br><span class="line">  <span class="attr">first</span>: T;</span><br><span class="line">  <span class="attr">second</span>: U;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">first: T, second: U</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">second</span> = second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pair = <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pair.<span class="property">first</span>);   <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pair.<span class="property">second</span>);  <span class="comment">// &quot;one&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Pair</code> 是一个带有两个泛型参数 <code>T</code> 和 <code>U</code> 的类，分别代表两个不同类型的值。</p>
<hr>
<h3 id="4-泛型约束与默认类型"><a href="#4-泛型约束与默认类型" class="headerlink" title="4. 泛型约束与默认类型"></a>4. <strong>泛型约束与默认类型</strong></h3><h4 id="4-1-泛型约束"><a href="#4-1-泛型约束" class="headerlink" title="4.1 泛型约束"></a>4.1 泛型约束</h4><p>泛型参数可以通过 <code>extends</code> 进行约束，确保传入的类型满足特定的条件：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> logLength&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">value</span>: T): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">logLength</span>(<span class="string">&quot;Hello&quot;</span>);    <span class="comment">// 合法，&quot;Hello&quot; 有 length 属性</span></span><br><span class="line"><span class="title function_">logLength</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">// 合法，[1, 2, 3] 有 length 属性</span></span><br><span class="line"><span class="title function_">logLength</span>(<span class="number">123</span>);        <span class="comment">// Error: Argument of type &#x27;123&#x27; is not assignable to parameter of type &#x27;Lengthwise&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>这里，我们通过 <code>T extends Lengthwise</code> 限制了 <code>T</code> 必须是具有 <code>length</code> 属性的类型。</p>
<h4 id="4-2-泛型默认类型"><a href="#4-2-泛型默认类型" class="headerlink" title="4.2 泛型默认类型"></a>4.2 泛型默认类型</h4><p>你还可以为泛型指定默认类型。如果调用时没有显式指定类型，TypeScript 将使用默认类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> wrap&lt;T = <span class="built_in">string</span>&gt;(<span class="attr">value</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapped = <span class="title function_">wrap</span>(<span class="number">123</span>);  <span class="comment">// T 被推导为 number</span></span><br><span class="line"><span class="keyword">let</span> wrappedString = <span class="title function_">wrap</span>(); <span class="comment">// T 默认为 string</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>wrap</code> 函数的泛型参数 <code>T</code> 默认是 <code>string</code>，但如果调用时显式指定了类型（如 <code>number</code>），则会使用指定的类型。</p>
<hr>
<h3 id="5-泛型的高级应用"><a href="#5-泛型的高级应用" class="headerlink" title="5. 泛型的高级应用"></a>5. <strong>泛型的高级应用</strong></h3><h4 id="5-1-使用多个泛型参数"><a href="#5-1-使用多个泛型参数" class="headerlink" title="5.1 使用多个泛型参数"></a>5.1 使用多个泛型参数</h4><p>你可以在一个函数、类或接口中使用多个泛型参数。常见的例子包括映射类型、双重泛型等。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, U&gt; &#123;</span><br><span class="line">  <span class="attr">first</span>: T;</span><br><span class="line">  <span class="attr">second</span>: U;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">first: T, second: U</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">second</span> = second;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">swap</span>(): <span class="title class_">Pair</span>&lt;U, T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="variable language_">this</span>.<span class="property">second</span>, <span class="variable language_">this</span>.<span class="property">first</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pair = <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> swappedPair = pair.<span class="title function_">swap</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(swappedPair.<span class="property">first</span>);  <span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(swappedPair.<span class="property">second</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Pair</code> 类接受两个泛型参数 <code>T</code> 和 <code>U</code>，并通过 <code>swap</code> 方法返回一个交换了类型的 <code>Pair</code> 对象。</p>
<h4 id="5-2-泛型与函数重载"><a href="#5-2-泛型与函数重载" class="headerlink" title="5.2 泛型与函数重载"></a>5.2 泛型与函数重载</h4><p>你还可以结合泛型和函数重载实现更加灵活的函数签名。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> merge&lt;T, U&gt;(<span class="attr">obj1</span>: T, <span class="attr">obj2</span>: U): T &amp; U &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merged = <span class="title function_">merge</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">30</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(merged); <span class="comment">// &#123; name: &quot;Alice&quot;, age: 30 &#125;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>merge</code> 函数接受两个对象并返回它们的交集类型，</p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 接口</title>
    <url>/2024/11/22/TypeScript-%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>在 TypeScript 中 <code>interface</code>（接口） 是一种用于定义对象结构的方式。它允许你定义对象的属性、方法、函数签名、类行为等的形状。接口提供了一个强类型的检查机制，帮助开发者在编写代码时保证对象的结构符合预期，并减少潜在的错误。</p>
<p>接口是 TypeScript 类型系统的核心之一，它的作用是描述对象的结构（包括属性和方法）和类的行为。接口可以通过继承、合并、混合等方式，使得 TypeScript 代码更加灵活、可复用和安全。</p>
<hr>
<h3 id="1-基本概念：接口的定义和使用"><a href="#1-基本概念：接口的定义和使用" class="headerlink" title="1. 基本概念：接口的定义和使用"></a>1. <strong>基本概念：接口的定义和使用</strong></h3><h4 id="1-1-定义接口"><a href="#1-1-定义接口" class="headerlink" title="1.1 定义接口"></a>1.1 定义接口</h4><p>使用 <code>interface</code> 关键字可以定义接口。接口描述对象的形状，也就是说，它指定了对象中应该包含哪些属性以及它们的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>Person</code> 是一个接口，包含两个属性：<code>name</code>（类型是 <code>string</code>）和 <code>age</code>（类型是 <code>number</code>）。</p>
<h4 id="1-2-使用接口"><a href="#1-2-使用接口" class="headerlink" title="1.2 使用接口"></a>1.2 使用接口</h4><p>定义了接口后，我们可以使用该接口来声明对象，确保对象符合接口定义的结构。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果对象的结构不符合接口定义，TypeScript 会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">invalidPerson</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span></span><br><span class="line">  <span class="comment">// Error: Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;Person&#x27;.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-接口的可选属性"><a href="#2-接口的可选属性" class="headerlink" title="2. 接口的可选属性"></a>2. <strong>接口的可选属性</strong></h3><p>接口中的属性可以通过在属性名后加上 <code>?</code> 来标记为可选属性。这意味着该属性可以存在，也可以缺失。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>;  <span class="comment">// age 是可选的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person1</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;   <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;  <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>age</code> 属性是可选的，<code>person1</code> 可以没有 <code>age</code> 属性，而 <code>person2</code> 可以有。</p>
<hr>
<h3 id="3-接口的只读属性"><a href="#3-接口的只读属性" class="headerlink" title="3. 接口的只读属性"></a>3. <strong>接口的只读属性</strong></h3><p>通过在接口的属性前加上 <code>readonly</code>，可以指定该属性是只读的，意味着一旦赋值后，不能再修改该属性的值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span>;  <span class="comment">// Error: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">35</span>;      <span class="comment">// This is allowed</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>name</code> 是只读属性，不能再修改其值。</p>
<hr>
<h3 id="4-接口的方法"><a href="#4-接口的方法" class="headerlink" title="4. 接口的方法"></a>4. <strong>接口的方法</strong></h3><p>接口不仅可以定义对象的属性，还可以定义方法。接口中的方法也可以有参数类型和返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="attr">message</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> says: <span class="subst">$&#123;message&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">greet</span>(<span class="string">&#x27;Hello!&#x27;</span>);  <span class="comment">// Alice says: Hello!</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，接口 <code>Person</code> 定义了一个 <code>greet</code> 方法，方法接受一个 <code>string</code> 类型的 <code>message</code> 参数，并返回 <code>void</code>。</p>
<hr>
<h3 id="5-接口的继承"><a href="#5-接口的继承" class="headerlink" title="5. 接口的继承"></a>5. <strong>接口的继承</strong></h3><p>接口支持继承，允许一个接口继承其他接口。这种方式可以扩展现有的接口，增加更多的属性和方法。</p>
<h4 id="5-1-单一继承"><a href="#5-1-单一继承" class="headerlink" title="5.1 单一继承"></a>5.1 单一继承</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Buddy&#x27;</span>,</span><br><span class="line">  <span class="attr">breed</span>: <span class="string">&#x27;Golden Retriever&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Dog</code> 接口继承了 <code>Animal</code> 接口，<code>Dog</code> 除了 <code>name</code> 属性外，还添加了 <code>breed</code> 属性。</p>
<h4 id="5-2-多重继承"><a href="#5-2-多重继承" class="headerlink" title="5.2 多重继承"></a>5.2 多重继承</h4><p>TypeScript 允许接口继承多个接口（多重继承）。这样，你可以创建一个组合多个接口的接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="attr">wheels</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Car</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>, <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="attr">brand</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">car</span>: <span class="title class_">Car</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tesla&#x27;</span>,</span><br><span class="line">  <span class="attr">wheels</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">brand</span>: <span class="string">&#x27;Model S&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Car</code> 接口继承了 <code>Animal</code> 和 <code>Vehicle</code> 两个接口，合并了它们的属性。</p>
<hr>
<h3 id="6-接口的类实现"><a href="#6-接口的类实现" class="headerlink" title="6. 接口的类实现"></a>6. <strong>接口的类实现</strong></h3><p>接口可以用于约束类的结构。类通过 <code>implements</code> 关键字来实现接口，类必须包含接口中定义的所有属性和方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Greetable</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Greetable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>);</span><br><span class="line">person.<span class="title function_">greet</span>();  <span class="comment">// Hello, Alice</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Person</code> 类实现了 <code>Greetable</code> 接口，必须实现 <code>greet</code> 方法。</p>
<h4 id="6-1-类实现多个接口"><a href="#6-1-类实现多个接口" class="headerlink" title="6.1 类实现多个接口"></a>6.1 类实现多个接口</h4><p>类也可以实现多个接口。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="title function_">fly</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">implements</span> <span class="title class_">Animal</span>, <span class="title class_">Flyable</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fly</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is flying`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bird = <span class="keyword">new</span> <span class="title class_">Bird</span>(<span class="string">&#x27;Eagle&#x27;</span>);</span><br><span class="line">bird.<span class="title function_">fly</span>();  <span class="comment">// Eagle is flying</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Bird</code> 类实现了 <code>Animal</code> 和 <code>Flyable</code> 两个接口。</p>
<hr>
<h3 id="7-接口的函数类型"><a href="#7-接口的函数类型" class="headerlink" title="7. 接口的函数类型"></a>7. <strong>接口的函数类型</strong></h3><p>接口不仅可以描述对象的结构，还可以描述函数的签名。接口可以指定一个函数的参数类型和返回值类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Add</span> &#123;</span><br><span class="line">  (<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">add</span>: <span class="title class_">Add</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Add</code> 接口描述了一个接受两个 <code>number</code> 类型的参数并返回一个 <code>number</code> 类型的函数签名。</p>
<hr>
<h3 id="8-索引签名"><a href="#8-索引签名" class="headerlink" title="8. 索引签名"></a>8. <strong>索引签名</strong></h3><p>索引签名允许你为接口添加任意数量的属性，而不需要事先定义每个属性。这对处理具有动态属性的对象非常有用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dictionary</span> &#123;</span><br><span class="line">  [<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">string</span>;  <span class="comment">// 允许字符串类型的键和对应的字符串值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dict</span>: <span class="title class_">Dictionary</span> = &#123;</span><br><span class="line">  <span class="attr">hello</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Dictionary</code> 接口允许对象拥有任意数量的 <code>string</code> 类型的键，并且值也必须是 <code>string</code> 类型。</p>
<hr>
<h3 id="9-混合类型的接口"><a href="#9-混合类型的接口" class="headerlink" title="9. 混合类型的接口"></a>9. <strong>混合类型的接口</strong></h3><p>有时候，你可能需要描述同时具有多个不同类型的对象，比如一个对象既有属性又有方法。可以通过接口来描述这种<strong>混合类型</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  (<span class="attr">start</span>: <span class="built_in">number</span>): <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">count</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">counter</span>: <span class="title class_">Counter</span> = <span class="function">(<span class="params">start: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">  counter.<span class="property">count</span> = start;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Counter started at <span class="subst">$&#123;start&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">counter.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>(<span class="number">5</span>));  <span class="comment">// Counter started at 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="property">count</span>);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Counter</code> 接口同时描述了一个函数类型和一个属性 <code>count</code>。</p>
<hr>
<h3 id="10-接口的声明合并"><a href="#10-接口的声明合并" class="headerlink" title="10. 接口的声明合并"></a>10. <strong>接口的声明合并</strong></h3><p>接口有一个有趣的特性，就是 <strong>声明合并</strong>。当多个接口声明同名时，TypeScript 会自动将它们合并成一个接口。这对于扩展已有接口非常有用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Window</span> &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">myWindow</span>: <span class="title class_">Window</span> = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Main Window&#x27;</span>,</span><br><span class="line">  <span class="attr">width</span>: <span class="number">800</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Window</code> 接口被声明了两次，TypeScript 会自动将两个声明合并为一个接口。因此 <code>Window</code> 既有 <code>title</code> 属性，也有 <code>width</code> 属性。</p>
<hr>
<h3 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. <strong>总结</strong></h3><ul>
<li><strong>接口</strong> 是 TypeScript 中用于描述对象、类、函数等类型的结构的一种方式。</li>
<li>接口可以定义<strong>属性</strong>、<strong>方法</strong>、<strong>可选属性</strong>、<strong>只读属性</strong>等。</li>
<li>接口支持<strong>继承</strong>，可以通过 <code>extends</code> 关键字继承多个接口，也可以被类实现。</li>
<li><strong>函数类型</strong>和<strong>混合类型</strong>可以通过接口来描述。</li>
<li>接口还支持<strong>声明合并</strong>，多个相同名字的接口会自动合并成一个接口。</li>
</ul>
]]></content>
      <tags>
        <tag>TypeScript</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC视频通话Demo</title>
    <url>/2024/11/24/WebRTC%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9DDemo/</url>
    <content><![CDATA[<p>使用 React 和 WebRTC 实现一个简单的视频通话 DEMO，WebRTC（Web Real-Time Communication）是一个支持网页和移动应用进行实时音视频通信的技术。下面我将详细描述如何创建一个基本的视频通话 DEMO。</p>
<h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><p>首先，我们需要确保以下几点：</p>
<ul>
<li>你已经安装了 Node.js 和 npm（或 yarn）。</li>
<li>React 项目已经创建并运行起来（如果还没有，可以使用 <code>create-react-app</code> 创建一个新的 React 项目）。</li>
</ul>
<h3 id="2-创建-React-项目"><a href="#2-创建-React-项目" class="headerlink" title="2. 创建 React 项目"></a>2. 创建 React 项目</h3><p>如果你还没有 React 项目，可以通过以下命令创建一个新的 React 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx create-react-app webrtc-demo</span><br><span class="line"><span class="built_in">cd</span> webrtc-demo</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<h3 id="3-安装-WebRTC-所需依赖"><a href="#3-安装-WebRTC-所需依赖" class="headerlink" title="3. 安装 WebRTC 所需依赖"></a>3. 安装 WebRTC 所需依赖</h3><p>WebRTC 本身不需要外部依赖，但为了更方便的管理代码，可以使用 WebRTC API 自带的功能。</p>
<h3 id="4-代码结构"><a href="#4-代码结构" class="headerlink" title="4. 代码结构"></a>4. 代码结构</h3><p>为了实现视频通话功能，涉及到以下几个关键的技术点：</p>
<ul>
<li>获取用户的媒体（摄像头和麦克风）流。</li>
<li>创建和管理 WebRTC 连接。</li>
<li>处理 ICE（Interactive Connectivity Establishment）候选者。</li>
<li>建立信号传输机制（例如使用 WebSocket 进行信令交换）。</li>
</ul>
<p>假设我们使用 WebSocket 作为信令服务器，前后端通信可以通过 WebSocket 来传递 SDP（Session Description Protocol）和 ICE 候选者。</p>
<h3 id="5-完整示例代码"><a href="#5-完整示例代码" class="headerlink" title="5. 完整示例代码"></a>5. 完整示例代码</h3><h4 id="1-创建一个信令服务器（使用-Node-js-和-WebSocket）"><a href="#1-创建一个信令服务器（使用-Node-js-和-WebSocket）" class="headerlink" title="1. 创建一个信令服务器（使用 Node.js 和 WebSocket）"></a>1. 创建一个信令服务器（使用 Node.js 和 WebSocket）</h4><p>首先，你需要一个简单的 WebSocket 信令服务器来传递 SDP 和 ICE 候选信息。可以创建一个新的 Node.js 项目并安装 <code>ws</code> 库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install ws</span><br></pre></td></tr></table></figure>

<p>在 <code>server.js</code> 文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">WebSocket</span> = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> <span class="title class_">WebSocket</span>.<span class="title class_">Server</span>(&#123; <span class="attr">port</span>: <span class="number">8080</span> &#125;);</span><br><span class="line"></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">    ws.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 广播给所有连接的客户端</span></span><br><span class="line">        wss.<span class="property">clients</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (client !== ws &amp;&amp; client.<span class="property">readyState</span> === <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123;</span><br><span class="line">                client.<span class="title function_">send</span>(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>启动信令服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure>

<h4 id="2-React-前端实现"><a href="#2-React-前端实现" class="headerlink" title="2. React 前端实现"></a>2. React 前端实现</h4><p>在 <code>src</code> 文件夹中，创建一个 <code>VideoCall.js</code> 组件来管理视频通话的逻辑。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// VideoCall.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useRef, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WebSocket 服务器地址</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">SIGNALING_SERVER</span> = <span class="string">&quot;ws://localhost:8080&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">VideoCall</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [isCaller, setIsCaller] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> localVideoRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> remoteVideoRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> peerConnectionRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> socketRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化 WebSocket 连接</span></span><br><span class="line">    socketRef.<span class="property">current</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="variable constant_">SIGNALING_SERVER</span>);</span><br><span class="line">  </span><br><span class="line">    socketRef.<span class="property">current</span>.<span class="property">onmessage</span> = <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message.<span class="property">data</span>);</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;offer&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">handleOffer</span>(data);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;answer&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">handleAnswer</span>(data);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">type</span> === <span class="string">&#x27;candidate&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">handleCandidate</span>(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (socketRef.<span class="property">current</span>) &#123;</span><br><span class="line">        socketRef.<span class="property">current</span>.<span class="title function_">close</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取用户的媒体流（摄像头和麦克风）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">startStream</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> stream = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(&#123;</span><br><span class="line">        <span class="attr">video</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">audio</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      localVideoRef.<span class="property">current</span>.<span class="property">srcObject</span> = stream;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error accessing media devices.&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 WebRTC 连接并发送 offer</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">startCall</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setIsCaller</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> peerConnection = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>(&#123;</span><br><span class="line">      <span class="attr">iceServers</span>: [&#123; <span class="attr">urls</span>: <span class="string">&quot;stun:stun.l.google.com:19302&quot;</span> &#125;],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    peerConnectionRef.<span class="property">current</span> = peerConnection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取本地媒体流并添加到 PeerConnection 中</span></span><br><span class="line">    <span class="keyword">const</span> localStream = localVideoRef.<span class="property">current</span>.<span class="property">srcObject</span>;</span><br><span class="line">    localStream.<span class="title function_">getTracks</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">track</span> =&gt;</span> peerConnection.<span class="title function_">addTrack</span>(track, localStream));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 offer 并发送给对方</span></span><br><span class="line">    <span class="keyword">const</span> offer = <span class="keyword">await</span> peerConnection.<span class="title function_">createOffer</span>();</span><br><span class="line">    <span class="keyword">await</span> peerConnection.<span class="title function_">setLocalDescription</span>(offer);</span><br><span class="line"></span><br><span class="line">    socketRef.<span class="property">current</span>.<span class="title function_">send</span>(</span><br><span class="line">      <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;offer&#x27;</span>, <span class="attr">offer</span>: offer &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 ICE 候选者</span></span><br><span class="line">    peerConnection.<span class="property">onicecandidate</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (event.<span class="property">candidate</span>) &#123;</span><br><span class="line">        socketRef.<span class="property">current</span>.<span class="title function_">send</span>(</span><br><span class="line">          <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;candidate&#x27;</span>, <span class="attr">candidate</span>: event.<span class="property">candidate</span> &#125;)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听远程流</span></span><br><span class="line">    peerConnection.<span class="property">ontrack</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      remoteVideoRef.<span class="property">current</span>.<span class="property">srcObject</span> = event.<span class="property">streams</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理收到的 offer</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleOffer</span> = <span class="keyword">async</span> (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> peerConnection = <span class="keyword">new</span> <span class="title class_">RTCPeerConnection</span>(&#123;</span><br><span class="line">      <span class="attr">iceServers</span>: [&#123; <span class="attr">urls</span>: <span class="string">&quot;stun:stun.l.google.com:19302&quot;</span> &#125;],</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    peerConnectionRef.<span class="property">current</span> = peerConnection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> localStream = localVideoRef.<span class="property">current</span>.<span class="property">srcObject</span>;</span><br><span class="line">    localStream.<span class="title function_">getTracks</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">track</span> =&gt;</span> peerConnection.<span class="title function_">addTrack</span>(track, localStream));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置远程描述</span></span><br><span class="line">    <span class="keyword">await</span> peerConnection.<span class="title function_">setRemoteDescription</span>(<span class="keyword">new</span> <span class="title class_">RTCSessionDescription</span>(data.<span class="property">offer</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 answer 并发送给对方</span></span><br><span class="line">    <span class="keyword">const</span> answer = <span class="keyword">await</span> peerConnection.<span class="title function_">createAnswer</span>();</span><br><span class="line">    <span class="keyword">await</span> peerConnection.<span class="title function_">setLocalDescription</span>(answer);</span><br><span class="line"></span><br><span class="line">    socketRef.<span class="property">current</span>.<span class="title function_">send</span>(</span><br><span class="line">      <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;answer&#x27;</span>, <span class="attr">answer</span>: answer &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 ICE 候选者</span></span><br><span class="line">    peerConnection.<span class="property">onicecandidate</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (event.<span class="property">candidate</span>) &#123;</span><br><span class="line">        socketRef.<span class="property">current</span>.<span class="title function_">send</span>(</span><br><span class="line">          <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;candidate&#x27;</span>, <span class="attr">candidate</span>: event.<span class="property">candidate</span> &#125;)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听远程流</span></span><br><span class="line">    peerConnection.<span class="property">ontrack</span> = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      remoteVideoRef.<span class="property">current</span>.<span class="property">srcObject</span> = event.<span class="property">streams</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理收到的 answer</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleAnswer</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">    peerConnectionRef.<span class="property">current</span>.<span class="title function_">setRemoteDescription</span>(<span class="keyword">new</span> <span class="title class_">RTCSessionDescription</span>(data.<span class="property">answer</span>));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理收到的 ICE 候选者</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleCandidate</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> candidate = <span class="keyword">new</span> <span class="title class_">RTCIceCandidate</span>(data.<span class="property">candidate</span>);</span><br><span class="line">    peerConnectionRef.<span class="property">current</span>.<span class="title function_">addIceCandidate</span>(candidate);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>WebRTC Video Call<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">video</span> <span class="attr">ref</span>=<span class="string">&#123;localVideoRef&#125;</span> <span class="attr">autoPlay</span> <span class="attr">muted</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">video</span> <span class="attr">ref</span>=<span class="string">&#123;remoteVideoRef&#125;</span> <span class="attr">autoPlay</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;!isCaller &amp;&amp; <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;startCall&#125;</span>&gt;</span>Start Call<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;startStream&#125;</span>&gt;</span>Start Stream<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">VideoCall</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-在-App-js-中引入-VideoCall-组件"><a href="#3-在-App-js-中引入-VideoCall-组件" class="headerlink" title="3. 在 App.js 中引入 VideoCall 组件"></a>3. 在 <code>App.js</code> 中引入 <code>VideoCall</code> 组件</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VideoCall</span> <span class="keyword">from</span> <span class="string">&#x27;./VideoCall&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>WebRTC Video Call Demo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">VideoCall</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-启动-React-项目"><a href="#6-启动-React-项目" class="headerlink" title="6. 启动 React 项目"></a>6. 启动 React 项目</h3><p>在项目根目录下，启动 React 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure>

<h3 id="7-测试视频通话"><a href="#7-测试视频通话" class="headerlink" title="7. 测试视频通话"></a>7. 测试视频通话</h3><ol>
<li>打开两个浏览器窗口，分别运行你的 React 应用。</li>
<li>点击 <code>Start Stream</code> 按钮来获取摄像头和麦克风流。</li>
<li>在其中一个窗口，点击 <code>Start Call</code> 按钮，另外一个窗口会接收到呼叫请求，并建立视频通话。</li>
</ol>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>这只是一个简单的 WebRTC 视频通话 Demo。实际生产环境中，还需要处理更多的情况，例如错误处理、信号服务器的健壮性、安全性等。希望这个示例能帮助你理解 WebRTC 的基本概念和如何在 React 中实现它！</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
</search>
